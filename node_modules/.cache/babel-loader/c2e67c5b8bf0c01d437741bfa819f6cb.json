{"ast":null,"code":"'use strict';\n\nL.SVG.include({\n  _updatecurve: function _updatecurve(layer) {\n    var svg_path = this._curvePointsToPath(layer._points);\n\n    this._setPath(layer, svg_path);\n\n    if (layer.options.animate) {\n      var path = layer._path;\n      var length = path.getTotalLength();\n\n      if (!layer.options.dashArray) {\n        path.style.strokeDasharray = length + ' ' + length;\n      }\n\n      if (layer._initialUpdate) {\n        path.animate([{\n          strokeDashoffset: length\n        }, {\n          strokeDashoffset: 0\n        }], layer.options.animate);\n        layer._initialUpdate = false;\n      }\n    }\n\n    return svg_path;\n  },\n  _curvePointsToPath: function _curvePointsToPath(points) {\n    var point = void 0,\n        curCommand = void 0,\n        str = '';\n\n    for (var i = 0; i < points.length; i++) {\n      point = points[i];\n\n      if (typeof point === 'string' || point instanceof String) {\n        curCommand = point;\n        str += curCommand;\n      } else str += point.x + ',' + point.y + ' ';\n    }\n\n    return str || 'M0 0';\n  }\n});\nvar Bezier = L.Path.extend({\n  options: {},\n  initialize: function initialize(path, icon, options) {\n    if (!path.mid || path.mid[0] === undefined) {\n      path.mid = this.getMidPoint(path.from, path.to, path.from.deep ? path.from.deep : 4, path.from.slide);\n    }\n\n    L.setOptions(this, options);\n    this._initialUpdate = true;\n    this.setPath(path);\n    this.icon = icon;\n  },\n  //Juast after path is added\n  onAdd: function onAdd(map) {\n    this._renderer._initPath(this);\n\n    this._reset();\n\n    this._renderer._addPath(this); // TODO ajust plane acording to zoom\n\n\n    map.on('zoom', function () {});\n  },\n  setAnimatePlane: function setAnimatePlane(path) {\n    var self = this;\n    if (this.spaceship_img) this.spaceship_img.remove();\n    var SnapSvg = Snap('.leaflet-overlay-pane>svg');\n    var spaceship_img = this.spaceship_img = SnapSvg.image(this.icon.path).attr({\n      visibility: \"hidden\"\n    });\n    var spaceship = SnapSvg.group(spaceship_img);\n    var flight_path = SnapSvg.path(path).attr({\n      'fill': 'none',\n      'stroke': 'none'\n    });\n    var full_path_length = Snap.path.getTotalLength(flight_path);\n    var half_path_length = full_path_length / 2;\n    var third_path_length = full_path_length / 3;\n    var forth_path_length = full_path_length / 4;\n\n    var width = forth_path_length / this._map.getZoom();\n\n    var height = forth_path_length / this._map.getZoom();\n\n    width = Math.min(Math.max(width, 30), 64);\n    height = Math.min(Math.max(height, 30), 64);\n    var last_step = 0;\n    Snap.animate(0, forth_path_length, function (step) {\n      //show image when plane start to animate\n      spaceship_img.attr({\n        visibility: \"visible\"\n      });\n      spaceship_img.attr({\n        width: width,\n        height: height,\n        class: self.icon.class\n      });\n      last_step = step;\n      var moveToPoint = Snap.path.getPointAtLength(flight_path, step);\n      var x = moveToPoint.x - width / 2;\n      var y = moveToPoint.y - height / 2;\n      spaceship.transform('translate(' + x + ',' + y + ') rotate(' + (moveToPoint.alpha - 90) + ', ' + width / 2 + ', ' + height / 2 + ')');\n    }, 2500, mina.easeout, function () {\n      Snap.animate(forth_path_length, half_path_length, function (step) {\n        last_step = step;\n        var moveToPoint = Snap.path.getPointAtLength(flight_path, step);\n        var x = moveToPoint.x - width / 2;\n        var y = moveToPoint.y - height / 2;\n        spaceship.transform('translate(' + x + ',' + y + ') rotate(' + (moveToPoint.alpha - 90) + ', ' + width / 2 + ', ' + height / 2 + ')');\n      }, 7000, mina.easein, function () {//done\n      });\n    });\n  },\n  getPath: function getPath() {\n    return this._coords;\n  },\n  setPath: function setPath(path) {\n    this._setPath(path);\n\n    return this.redraw();\n  },\n  getBounds: function getBounds() {\n    return this._bounds;\n  },\n  getMidPoint: function getMidPoint(from, to, deep) {\n    var round_side = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'LEFT_ROUND';\n    var offset = 3.14;\n    if (round_side === 'RIGHT_ROUND') offset = offset * -1;\n    var latlngs = [];\n    var latlng1 = from,\n        latlng2 = to;\n    var offsetX = latlng2.lng - latlng1.lng,\n        offsetY = latlng2.lat - latlng1.lat;\n    var r = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2)),\n        theta = Math.atan2(offsetY, offsetX);\n    var thetaOffset = offset / (deep ? deep : 4);\n    var r2 = r / 2 / Math.cos(thetaOffset),\n        theta2 = theta + thetaOffset;\n    var midpointX = r2 * Math.cos(theta2) + latlng1.lng,\n        midpointY = r2 * Math.sin(theta2) + latlng1.lat;\n    var midpointLatLng = [midpointY, midpointX];\n    latlngs.push(latlng1, midpointLatLng, latlng2);\n    return midpointLatLng;\n  },\n  _setPath: function _setPath(path) {\n    this._coords = path;\n    this._bounds = this._computeBounds();\n  },\n  _computeBounds: function _computeBounds() {\n    var bound = new L.LatLngBounds();\n    bound.extend(this._coords.from);\n    bound.extend(this._coords.to); //for single destination\n\n    bound.extend(this._coords.mid);\n    return bound;\n  },\n  getCenter: function getCenter() {\n    return this._bounds.getCenter();\n  },\n  _update: function _update() {\n    if (!this._map) {\n      return;\n    }\n\n    this._updatePath();\n  },\n  _updatePath: function _updatePath() {\n    //animated plane\n    var path = this._renderer._updatecurve(this);\n\n    this.setAnimatePlane(path);\n  },\n  _project: function _project() {\n    this._points = [];\n\n    this._points.push('M');\n\n    var curPoint = this._map.latLngToLayerPoint(this._coords.from);\n\n    this._points.push(curPoint);\n\n    if (this._coords.mid) {\n      this._points.push('Q');\n\n      curPoint = this._map.latLngToLayerPoint(this._coords.mid);\n\n      this._points.push(curPoint);\n    }\n\n    curPoint = this._map.latLngToLayerPoint(this._coords.to);\n\n    this._points.push(curPoint);\n  }\n});\n\nL.bezier = function (config, options) {\n  var paths = [];\n\n  for (var i = 0; config.path.length > i; i++) {\n    var last_destination = false;\n\n    for (var c = 0; config.path[i].length > c; c++) {\n      var current_destination = config.path[i][c];\n\n      if (last_destination) {\n        var path_pair = {\n          from: last_destination,\n          to: current_destination\n        };\n        paths.push(new Bezier(path_pair, config.icon, options));\n      }\n\n      last_destination = config.path[i][c];\n    }\n  }\n\n  return L.layerGroup(paths);\n};","map":null,"metadata":{},"sourceType":"script"}